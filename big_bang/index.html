<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Big Bang Simulation with Adjustable Star Size & Hover Effect</title>
  <style>
    /* Ensure the canvas fills the window */
    body { margin: 0; overflow: hidden; background-color: #000; }
    canvas { display: block; }
  </style>
  <!-- Import map to resolve "three" -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <!-- Run this via a local server -->
  <script type="module">
    // Import Three.js and supporting modules.
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { GUI } from 'https://unpkg.com/dat.gui@0.7.7/build/dat.gui.module.js';

    /**********************************************************************
     * Simulation Parameters â€“ adjustable via dat.GUI.
     **********************************************************************/
    const params = {
      expansionSpeed: 50.0,       // Particle expansion speed.
      particleCount: 3500,        // Total number of particles.
      autoZoom: false,            // Auto zoom disabled.
      zoomSpeed: 0,               // Zoom speed is 0.
      expansionDuration: 0.95,     // Seconds until expansion stops.
      starRotationSpeed: 0.05,    // Rotation speed (radians per second) after expansion.
      backgroundURL: "D:\Projekte\o3-Mini\NewAIWorld\big_bang\BackgroundEnhanced.jpg", // Background image URL.
      starIntensity: 10.0,        // Multiplier for star brightness.
      hoverThreshold: 1000,       // Hover threshold in screen pixels.
      starSize: 2,                // Initial star size (in pixels).
      hoverStarSize: 4            // Star size when hovered (doubled).
    };

    /**********************************************************************
     * Global Constants for Logo Construction
     **********************************************************************/
    const outerRadius = 5;
    const innerRadius = 4;
    const depth = 1;

    // Global logo colors.
    const red    = 0xEA4335;
    const blue   = 0x4285F4;
    const yellow = 0xFBBC05;
    const green  = 0x34A853;

    /**********************************************************************
     * Global Variables
     **********************************************************************/
    let scene, camera, renderer, controls, composer;
    let particleSystem, particleGeometry;
    let velocities;  // Array of velocities for each star.
    let clock, gui;
    let googleLogoGroup, openaiLogoGroup;
    let currentHoveredIndex = -1;  // Index of the currently hovered star.
    const mouse = new THREE.Vector2();  // Global mouse coordinates (in NDC).

    // Default star colors.
    const defaultStarColor = new THREE.Color(0.3, 0.3, 0.3);
    const hoverStarColor   = new THREE.Color(1, 1, 1);

    /**********************************************************************
     * Shaders for Custom Points Material
     **********************************************************************/
    const vertexShader = `
      attribute float aSize;
      attribute vec3 aColor;
      varying vec3 vColor;
      void main() {
        vColor = aColor;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * mvPosition;
        gl_PointSize = aSize;
      }
    `;

    const fragmentShader = `
      uniform sampler2D pointTexture;
      varying vec3 vColor;
      void main() {
        vec4 texColor = texture2D(pointTexture, gl_PointCoord);
        gl_FragColor = vec4(vColor, 1.0) * texColor;
      }
    `;

    /**********************************************************************
     * Initialization: Scene, Camera, Renderer, Lights, Controls & Effects
     **********************************************************************/
    function init() {
      // Create the scene.
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      scene.fog = new THREE.FogExp2(0x000000, 0.00015);

      // Set up the camera.
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
      camera.position.set(0, 0, 50);

      // Set up the renderer.
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // OrbitControls.
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Lights.
      scene.add(new THREE.AmbientLight(0xffffff, 0.2));
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.set(1024, 1024);
      scene.add(directionalLight);

      // Clock.
      clock = new THREE.Clock();

      // Build the particle system.
      createParticleSystem();

      // Postprocessing (bloom effect).
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
      composer.addPass(bloomPass);

      // Create logos.
      googleLogoGroup = createGoogleLogo();
      googleLogoGroup.scale.set(0.3, 0.3, 0.3);
      googleLogoGroup.position.set(-3, 3, 3);
      scene.add(googleLogoGroup);

      openaiLogoGroup = createOpenAILogo();
      openaiLogoGroup.scale.set(0.3, 0.3, 0.3);
      openaiLogoGroup.position.set(3, -3, -3);
      scene.add(openaiLogoGroup);

      // dat.GUI.
      gui = new GUI();
      gui.add(params, 'expansionSpeed', 0, 200).name("Expansion Speed");
      gui.add(params, 'expansionDuration', 0, 60).name("Expansion Duration (s)");
      gui.add(params, 'starRotationSpeed', 0, 0.2).name("Star Rotation Speed");
      gui.add(params, 'starIntensity', 0, 100).name("Star Intensity");
      gui.add(params, 'hoverThreshold', 1, 2000).name("Hover Threshold (px)");
      gui.add(params, 'starSize', 0, 20).name("Initial Star Size");
      gui.add(params, 'hoverStarSize', 0, 40).name("Hover Star Size");
      gui.add(params, 'autoZoom').name("Auto Zoom");
      gui.add(params, 'zoomSpeed', 0, 20).name("Zoom Speed");
      gui.add(params, 'backgroundURL').name("Background URL").onFinishChange(loadBackgroundImage);

      // Event listeners.
      window.addEventListener('resize', onWindowResize, false);
      renderer.domElement.addEventListener('click', onDocumentClick, false);
      renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
    }

    /**********************************************************************
     * Create the Particle System with Custom Shader Material
     **********************************************************************/
    function createParticleSystem() {
      particleGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(params.particleCount * 3);
      const colors = new Float32Array(params.particleCount * 3);
      const sizes = new Float32Array(params.particleCount);
      velocities = new Float32Array(params.particleCount * 3);

      // Initialize positions, velocities, colors, and sizes.
      for (let i = 0; i < params.particleCount; i++) {
        const index = i * 3;
        const r = Math.random() * 0.5;
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos((Math.random() * 2) - 1);
        positions[index] = r * Math.sin(phi) * Math.cos(theta);
        positions[index + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[index + 2] = r * Math.cos(phi);

        const speed = Math.random() * 0.5 + 0.5;
        velocities[index] = speed * Math.sin(phi) * Math.cos(theta);
        velocities[index + 1] = speed * Math.sin(phi) * Math.sin(theta);
        velocities[index + 2] = speed * Math.cos(phi);

        // Set default color (multiplied by intensity) and size.
        colors[index] = defaultStarColor.r * params.starIntensity;
        colors[index + 1] = defaultStarColor.g * params.starIntensity;
        colors[index + 2] = defaultStarColor.b * params.starIntensity;
        sizes[i] = params.starSize;
      }

      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
      particleGeometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

      const texture = createParticleTexture();

      const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: { pointTexture: { value: texture } },
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: true,
        depthTest: false,
        blending: THREE.AdditiveBlending
      });

      particleSystem = new THREE.Points(particleGeometry, shaderMaterial);
      scene.add(particleSystem);
    }

    /**********************************************************************
     * Create a Glowing Particle Texture
     **********************************************************************/
    function createParticleTexture() {
      const size = 64;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const context = canvas.getContext('2d');
      const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.4, 'rgba(128,128,255,0.6)');
      gradient.addColorStop(1, 'rgba(0,0,128,0)');
      context.fillStyle = gradient;
      context.fillRect(0, 0, size, size);
      return new THREE.CanvasTexture(canvas);
    }

    /**********************************************************************
     * Custom Hover Effect: Update Colors and Sizes of Stars
     **********************************************************************/
    // Manually project each star to screen space and check if it is within the threshold.
    function checkHover() {
      let closestIndex = -1;
      let minDistance = Infinity;
      const positions = particleGeometry.attributes.position.array;
      const vector = new THREE.Vector3();
      const threshold = params.hoverThreshold;
      for (let i = 0; i < params.particleCount; i++) {
        const index = i * 3;
        vector.set(positions[index], positions[index + 1], positions[index + 2]);
        particleSystem.localToWorld(vector);
        vector.project(camera);
        const screenX = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const screenY = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        const mouseX = (mouse.x * 0.5 + 0.5) * window.innerWidth;
        const mouseY = (-mouse.y * 0.5 + 0.5) * window.innerHeight;
        const dx = screenX - mouseX;
        const dy = screenY - mouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < threshold && distance < minDistance) {
          minDistance = distance;
          closestIndex = i;
        }
      }
      return closestIndex;
    }

    // Update the aColor and aSize attributes.
    function updateStarAttributes(hoveredIndex) {
      const colors = particleGeometry.attributes.aColor.array;
      const sizes = particleGeometry.attributes.aSize.array;
      for (let i = 0; i < params.particleCount; i++) {
        let baseColor, baseSize;
        if (i === hoveredIndex) {
          baseColor = hoverStarColor.clone().multiplyScalar(params.starIntensity);
          baseSize = params.hoverStarSize;
        } else {
          baseColor = defaultStarColor.clone().multiplyScalar(params.starIntensity);
          baseSize = params.starSize;
        }
        colors[i * 3] = baseColor.r;
        colors[i * 3 + 1] = baseColor.g;
        colors[i * 3 + 2] = baseColor.b;
        sizes[i] = baseSize;
      }
      particleGeometry.attributes.aColor.needsUpdate = true;
      particleGeometry.attributes.aSize.needsUpdate = true;
    }

    /**********************************************************************
     * Google Logo Construction
     **********************************************************************/
    function createRingSegment(startAngle, endAngle, color) {
      const material = new THREE.MeshPhongMaterial({ color: color, side: THREE.DoubleSide });
      const shape = new THREE.Shape();
      shape.absarc(0, 0, outerRadius, startAngle, endAngle, false);
      shape.lineTo(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));
      shape.absarc(0, 0, innerRadius, endAngle, startAngle, true);
      shape.lineTo(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));
      const extrudeSettings = { depth: depth, bevelEnabled: false };
      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      return new THREE.Mesh(geometry, material);
    }

    function createBlueGSegment(color) {
      const material = new THREE.MeshPhongMaterial({ color: color, side: THREE.DoubleSide });
      const shape = new THREE.Shape();
      shape.moveTo(1, -0.5);
      shape.lineTo(outerRadius, -0.5);
      shape.lineTo(outerRadius, -2);
      shape.lineTo(1, -2);
      shape.lineTo(1, -0.5);
      const extrudeSettings = { depth: depth, bevelEnabled: false };
      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      return new THREE.Mesh(geometry, material);
    }

    function createGoogleLogo() {
      const group = new THREE.Group();
      const segRed = createRingSegment(Math.PI * 0.2, Math.PI * 0.57, red);
      const segYellow = createRingSegment(Math.PI * 0.57, Math.PI * 0.93, yellow);
      const segGreen = createRingSegment(Math.PI * 0.93, Math.PI * 1.58, green);
      const segBlue = createRingSegment(Math.PI * 1.58, Math.PI * 1.95, blue);
      const blueG = createBlueGSegment(blue);
      group.add(segRed);
      group.add(segYellow);
      group.add(segGreen);
      group.add(segBlue);
      group.add(blueG);
      group.name = "googleLogo";
      return group;
    }

    /**********************************************************************
     * OpenAI Logo Construction
     **********************************************************************/
    function createOpenAILogo() {
      const group = new THREE.Group();
      const openaiColor = 0x333333;
      const shape = new THREE.Shape();
      const numPoints = 64;
      const baseRadius = 5;
      for (let i = 0; i < numPoints; i++) {
        let angle = (i / numPoints) * Math.PI * 2;
        let modulation = 0.5 * Math.sin(6 * angle);
        let r = baseRadius + modulation;
        let x = r * Math.cos(angle);
        let y = r * Math.sin(angle);
        if (i === 0) {
          shape.moveTo(x, y);
        } else {
          shape.lineTo(x, y);
        }
      }
      shape.closePath();
      const hole = new THREE.Path();
      const innerRadiusOpenAI = 3.5;
      const numHolePoints = 64;
      for (let i = 0; i < numHolePoints; i++) {
        let angle = (i / numHolePoints) * Math.PI * 2;
        let x = innerRadiusOpenAI * Math.cos(angle);
        let y = innerRadiusOpenAI * Math.sin(angle);
        if (i === 0) {
          hole.moveTo(x, y);
        } else {
          hole.lineTo(x, y);
        }
      }
      hole.closePath();
      shape.holes.push(hole);
      const extrudeSettings = { depth: 1, bevelEnabled: false };
      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      const material = new THREE.MeshPhongMaterial({ color: openaiColor, side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(geometry, material);
      group.add(mesh);
      group.name = "openaiLogo";
      return group;
    }

    /**********************************************************************
     * Background Image Loader
     **********************************************************************/
    function loadBackgroundImage(url) {
      if (!url) {
        scene.background = new THREE.Color(0x000000);
        return;
      }
      const loader = new THREE.TextureLoader();
      loader.load(
        url,
        function(texture) {
          scene.background = texture;
        },
        undefined,
        function(err) {
          console.error("Error loading background image:", err);
          scene.background = new THREE.Color(0x000000);
        }
      );
    }

    /**********************************************************************
     * Click Detection: Open Website on Logo Click
     **********************************************************************/
    function onDocumentClick(event) {
      event.preventDefault();
      const raycasterLogos = new THREE.Raycaster();
      raycasterLogos.setFromCamera(mouse, camera);
      const intersectsGoogle = raycasterLogos.intersectObjects(googleLogoGroup.children, true);
      const intersectsOpenAI = raycasterLogos.intersectObjects(openaiLogoGroup.children, true);
      if (intersectsGoogle.length > 0) {
        window.open("https://www.google.com", "_blank");
      } else if (intersectsOpenAI.length > 0) {
        window.open("https://www.openai.com", "_blank");
      }
    }

    /**********************************************************************
     * Mouse Move: Update Global Mouse Coordinates
     **********************************************************************/
    function onDocumentMouseMove(event) {
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    }

    /**********************************************************************
     * Animation Loop: Update Particles, Hover, Rotation, Render
     **********************************************************************/
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      // Expand particles until expansionDuration.
      if (elapsed < params.expansionDuration) {
        const positions = particleGeometry.attributes.position.array;
        for (let i = 0; i < params.particleCount; i++) {
          const index = i * 3;
          positions[index]     += velocities[index] * params.expansionSpeed * delta;
          positions[index + 1] += velocities[index + 1] * params.expansionSpeed * delta;
          positions[index + 2] += velocities[index + 2] * params.expansionSpeed * delta;
        }
        particleGeometry.attributes.position.needsUpdate = true;
      } else {
        particleSystem.rotation.y += params.starRotationSpeed * delta;
      }

      // Custom hover effect.
      const hoveredIndex = checkHover();
      updateStarAttributes(hoveredIndex);

      if (params.autoZoom) {
        camera.position.z += params.zoomSpeed * delta;
      }

      if (googleLogoGroup) { googleLogoGroup.rotation.y += 0.01; }
      if (openaiLogoGroup) { openaiLogoGroup.rotation.y += 0.01; }

      controls.update();
      composer.render();
    }

    /**********************************************************************
     * Handle Window Resize
     **********************************************************************/
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    // Initialize and start the animation.
    init();
    animate();
  </script>
</body>
</html>
